<?php

namespace glex;

use glex\hunspellFFI\hunspellFFI;
use glex\hunspellFFI\string_;
use FFI;

/**
 * Hunspell spell checker FFI wrapper class
 */
class hunspell {

    /** @var glex\hunspellFFI\hunspellFFI The FFI class */
    private $hunspellFFI;

    /** @var glex\hunspellFFI\Hunhandle_ptr The hunspell handle */
    private $hunhandle;


    /**
     * Constructor of the hunspell FFI wrapper
     * @param string $aff Path of the affix file
     * @param string $dic Path of the dictionary file
     * @param string $pathToSoFile Path of the compiled hunspell library SO file
     */
    public function __construct(string $aff, string $dic, string $pathToSoFile = hunspellFFI::SOFILE) {
        $this->hunspellFFI = new hunspellFFI($pathToSoFile);
        $this->hunhandle   = $this->hunspellFFI->Hunspell_create($aff, $dic);
    }


    /**
     * Destructor
     */
    public function __destruct() {
        $this->hunspellFFI->Hunspell_destroy($this->hunhandle);
    }

    /**
     * Checks if a word is spelled correctly.
     * output: 0 = bad word, not 0 = good word
     * @param string $word
     * @return int output: 0 = bad word, not 0 = good word
     */
    public function spell(string $word) {
        return $this->hunspellFFI->Hunspell_spell($this->hunhandle, $word);
    }

    /**
     * Retrieve suggestions for misspelled word.
     * @param string $word
     * @return type
     */
    public function suggest(string $word) {
        return $this->handleList('Hunspell_suggest', [$word]);
    }

    /**
     * Performs morphological analysis on the word.
     * @param string $word
     * @return type
     */
    public function analyze(string $word) {
        return $this->handleList('Hunspell_analyze', [$word]);
    }

    /**
     * Returns the stems for a word.
     * @param string $word
     * @return array
     */
    public function stem(string $word) {
        return $this->handleList('Hunspell_stem', [$word]);
    }


    /**
     * Declensions can be generated by providing a sample to the generate method.
     * @param string $word1
     * @param string $word2
     * @return array
     */
    public function generate(string $word1, string $word2) {
        return $this->handleList('Hunspell_generate', [$word1, $word2]);
    }

    /**
     * Adds a custom word to the dictionary.
     * @param string $word
     * @return type
     */
    public function add(string $word) {
        return $this->hunspellFFI->Hunspell_add($this->hunhandle, $word);
    }

    /**
     * Removes a custom word from the dictionary.
     * @param string $word
     * @return type
     */
    public function remove(string $word) {
        return $this->hunspellFFI->Hunspell_remove($this->hunhandle, $word);
    }


    private function handleList(string $func, array $args) {
        $res1 = new string_($this->hunspellFFI->getFFI()->new('char*'));
        $res2 = $res1->addr();
        $res3 = $res2->addr();

        $size = call_user_func_array(array($this->hunspellFFI, $func), array_merge([$this->hunhandle, $res3], $args));

        $result = [];
        for ($i = 0; $i < $size; $i++) {
            $deref    = $res2->deref($i);
            $result[] = $deref->toString();
        }

        $this->hunspellFFI->Hunspell_free_list($this->hunhandle, $res3, $size);

        FFI::free($res3->getData());
        FFI::free($res2->getData());
        FFI::free($res1->getData());

        return $result;
    }


}
